<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Фигуры как нарисованные от руки</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        canvas {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            cursor: default;
        }
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            width: 200px;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover { background: #0056b3; }
        .slider-container { margin: 10px 0; }
        .slider-container label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 14px;
        }
        .slider {
            width: 100%;
            height: 5px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
        }
        .value-display { font-size: 12px; color: #666; margin-top: 2px; }
    </style>
</head>
<body>
    <div class="controls">
        <h3>Управление</h3>
        <button id="addShapeButton">Добавить фигуру</button>
        <button id="clearCanvasButton">Очистить</button>
    </div>
    
    <canvas id="canvas" width="800" height="600"></canvas>

    <script>
    class CanvasEditor {
        /**
         * Конструктор класса. Инициализирует canvas, состояние, события и начальные фигуры.
         * @param {string} canvasId - id элемента canvas
         */
        constructor(canvasId) {
            this.canvas = document.getElementById(canvasId);
            this.ctx = this.canvas.getContext('2d');
            this.interaction = { isDragging: false, isResizing: false, selectedShape: null, dragOffset: {x:0,y:0}, resizeHandle: null };
            this.shapes = [
                { type: 'rectangle', x: 150, y: 100, width: 200, height: 120, color: '#ff6b6b', strokeWidth: 3, selected: false },
                { type: 'circle', x: 500, y: 200, radius: 80, color: '#4ecdc4', strokeWidth: 4, selected: false }
            ];
            this.attachEvents();
            this.drawShapes();
        }

        /**
         * Рисует фигуру на canvas.
         * @param {Object} shape - объект фигуры
         */
        drawShape(shape) {
            const ctx = this.ctx;
            ctx.save();
            ctx.strokeStyle = shape.color;
            ctx.lineWidth = shape.strokeWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            if (shape.type === 'rectangle') {
                ctx.strokeRect(shape.x, shape.y, shape.width, shape.height);
            } else if (shape.type === 'circle') {
                ctx.arc(shape.x, shape.y, shape.radius, 0, Math.PI * 2);
                ctx.stroke();
            }
            ctx.restore();
        }

        /**
         * Рисует выделение и ручки изменения размера для выбранной фигуры.
         * @param {Object} shape - объект фигуры
         */
        drawSelection(shape) {
            if (!shape.selected) return;
            const ctx = this.ctx;
            const bounds = this.getShapeBounds(shape);
            const offset = 5;
            ctx.save();
            ctx.strokeStyle = '#007bff';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(
                bounds.x - offset,
                bounds.y - offset,
                bounds.width + offset * 2,
                bounds.height + offset * 2
            );
            ctx.fillStyle = '#007bff';
            ctx.setLineDash([]);
            const handles = [
                [bounds.x - offset, bounds.y - offset],
                [bounds.x + bounds.width + offset, bounds.y - offset],
                [bounds.x + bounds.width + offset, bounds.y + bounds.height + offset],
                [bounds.x - offset, bounds.y + bounds.height + offset],
                [bounds.x + bounds.width/2, bounds.y - offset],
                [bounds.x + bounds.width + offset, bounds.y + bounds.height/2],
                [bounds.x + bounds.width/2, bounds.y + bounds.height + offset],
                [bounds.x - offset, bounds.y + bounds.height/2]
            ];
            handles.forEach(([x, y]) => ctx.fillRect(x - 4, y - 4, 8, 8));
            ctx.restore();
        }

        /**
         * Очищает canvas и отрисовывает все фигуры.
         */
        drawShapes() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

            this.shapes.forEach(shape => {
                this.drawShape(shape);
                this.drawSelection(shape);
            });
        }

        /**
         * Возвращает координаты мыши относительно canvas.
         * @param {MouseEvent} e - событие мыши
         * @returns {{x: number, y: number}} координаты мыши
         */
        getMousePos(e) {
            return { x: e.offsetX, y: e.offsetY };
        }

        /**
         * Возвращает габаритный прямоугольник фигуры.
         * @param {Object} shape - объект фигуры
         * @returns {{x: number, y: number, width: number, height: number}} габариты
         */
        getShapeBounds(shape) {
            switch(shape.type) {
                case 'rectangle': return { x: shape.x, y: shape.y, width: shape.width, height: shape.height };
                case 'circle': return { x: shape.x - shape.radius, y: shape.y - shape.radius, width: shape.radius * 2, height: shape.radius * 2 };
            }
        }

        /**
         * Проверяет, находится ли точка (x, y) внутри фигуры.
         * @param {number} x - координата X
         * @param {number} y - координата Y
         * @param {Object} shape - объект фигуры
         * @returns {boolean} true, если точка внутри фигуры
         */
        isPointInShape(x, y, shape) {
            const bounds = this.getShapeBounds(shape);
            if (shape.type === 'circle') {
                const dx = x - shape.x, dy = y - shape.y;
                return dx * dx + dy * dy <= shape.radius * shape.radius;
            }
            return x >= bounds.x && x <= bounds.x + bounds.width && y >= bounds.y && y <= bounds.y + bounds.height;
        }

        /**
         * Проверяет, находится ли точка (x, y) на ручке изменения размера фигуры.
         * @param {number} x - координата X
         * @param {number} y - координата Y
         * @param {Object} shape - объект фигуры
         * @returns {Object|null} объект ручки или null
         */
        getHandleAt(x, y, shape) {
            if (!shape.selected) return null;
            const bounds = this.getShapeBounds(shape);
            const handles = [
                {x: bounds.x, y: bounds.y, type: 'nw'}, {x: bounds.x + bounds.width, y: bounds.y, type: 'ne'},
                {x: bounds.x + bounds.width, y: bounds.y + bounds.height, type: 'se'}, {x: bounds.x, y: bounds.y + bounds.height, type: 'sw'}
            ];
            return handles.find(h => Math.abs(x - h.x) <= 8 && Math.abs(y - h.y) <= 8) || null;
        }

        /**
         * Изменяет размер фигуры в зависимости от ручки и положения мыши.
         * @param {Object} shape - объект фигуры
         * @param {Object} handle - объект ручки
         * @param {Object} mouse - координаты мыши
         */
        resizeShape(shape, handle, mouse) {
            if (shape.type === 'rectangle') {
                const { type } = handle;
                if (type === 'se') {
                    shape.width = Math.max(20, mouse.x - shape.x);
                    shape.height = Math.max(20, mouse.y - shape.y);
                } else if (type === 'nw') {
                    const newW = Math.max(20, shape.x + shape.width - mouse.x);
                    const newH = Math.max(20, shape.y + shape.height - mouse.y);
                    shape.x = shape.x + shape.width - newW;
                    shape.y = shape.y + shape.height - newH;
                    shape.width = newW;
                    shape.height = newH;
                }
            } else if (shape.type === 'circle') {
                const dx = mouse.x - shape.x, dy = mouse.y - shape.y;
                shape.radius = Math.max(20, Math.sqrt(dx * dx + dy * dy));
            }
            this.drawShapes();
        }

        /**
         * Навешивает обработчики событий мыши на canvas.
         */
        attachEvents() {
            this.canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
            this.canvas.addEventListener('mousemove', this.onMouseMove.bind(this));
            this.canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        }

        /**
         * Обработчик события нажатия мыши по canvas.
         * @param {MouseEvent} e - событие мыши
         */
        onMouseDown(e) {
            const mouse = this.getMousePos(e);
            for (const shape of this.shapes) {
                if (shape.selected) {
                    const handle = this.getHandleAt(mouse.x, mouse.y, shape);
                    if (handle) {
                        this.interaction = { ...this.interaction, isResizing: true, selectedShape: shape, resizeHandle: handle };
                        return;
                    }
                }
            }
            this.shapes.forEach(s => s.selected = false);
            for (let i = this.shapes.length - 1; i >= 0; i--) {
                if (this.isPointInShape(mouse.x, mouse.y, this.shapes[i])) {
                    this.shapes[i].selected = true;
                    const shape = this.shapes[i];
                    this.interaction = {
                        isDragging: true, selectedShape: shape,
                        dragOffset: {
                            x: mouse.x - shape.x,
                            y: mouse.y - shape.y
                        }
                    };
                    console.log(this.interaction);
                    break;
                }
            }
            this.drawShapes();
        }

        /**
         * Обработчик события движения мыши по canvas.
         * @param {MouseEvent} e - событие мыши
         */
        onMouseMove(e) {
            const mouse = this.getMousePos(e);
            let cursor = 'default';
            if (this.interaction.isDragging) {
                const shape = this.interaction.selectedShape;
                shape.x = mouse.x - this.interaction.dragOffset.x;
                shape.y = mouse.y - this.interaction.dragOffset.y;
                this.drawShapes();
                cursor = 'move';
            } else if (this.interaction.isResizing) {
                this.resizeShape(this.interaction.selectedShape, this.interaction.resizeHandle, mouse);
                cursor = 'nwse-resize';
            } else {
                // Проверяем, наведена ли мышь на выделенную фигуру
                let hoveredSelected = false;
                let hovered = false;
                for (let i = this.shapes.length - 1; i >= 0; i--) {
                    const shape = this.shapes[i];
                    if (this.isPointInShape(mouse.x, mouse.y, shape)) {
                        hovered = true;
                        if (shape.selected) {
                            hoveredSelected = true;
                        }
                        break;
                    }
                }
                if (hoveredSelected) {
                    cursor = 'move';
                } else if (hovered) {
                    cursor = 'pointer';
                }
            }
            this.canvas.style.cursor = cursor;
        }

        /**
         * Обработчик события отпускания кнопки мыши.
         */
        onMouseUp() {
            this.interaction = { isDragging: false, isResizing: false, selectedShape: null, dragOffset: {x:0,y:0}, resizeHandle: null };
        }

        /**
         * Добавляет случайную фигуру на холст.
         */
        addRandomShape() {
            const types = ['rectangle', 'circle'];
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7', '#dda0dd'];
            const type = types[Math.floor(Math.random() * 2)];
            const color = colors[Math.floor(Math.random() * colors.length)];
            let newShape = { type, color, strokeWidth: Math.random() * 3 + 2, selected: false };
            if (type === 'rectangle') {
                Object.assign(newShape, { x: Math.random() * 600 + 50, y: Math.random() * 400 + 50, width: Math.random() * 150 + 100, height: Math.random() * 100 + 80 });
            } else if (type === 'circle') {
                Object.assign(newShape, { x: Math.random() * 600 + 100, y: Math.random() * 400 + 100, radius: Math.random() * 60 + 40 });
            }
            this.shapes.push(newShape);
            this.drawShapes();
        }

        /**
         * Очищает холст и удаляет все фигуры.
         */
        clearCanvas() {
            this.shapes = [];
            this.drawShapes();
        }
    }
    
    // Создание экземпляра и подключение элементов управления интерфейса
    document.addEventListener('DOMContentLoaded', () => {
        const canvasEditor = new CanvasEditor('canvas');
        document.getElementById('addShapeButton').addEventListener('click', () => canvasEditor.addRandomShape());
        document.getElementById('clearCanvasButton').addEventListener('click', () => canvasEditor.clearCanvas());
    });
    </script>
</body>
</html>